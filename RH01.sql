WITH ASSIGN_PARAM AS (

SELECT 
CASE WHEN :P_AsgNumber IS NULL THEN SYSDATE
ELSE NVL(:P_UpdateDate, SYSDATE) END AS EXTRACTION_DATE

--ELSE TRUNC(NVL(TO_DATE(TO_CHAR(:P_UpdateDate, 'YYYY-MM-DD'), 'YYYY-MM-DD'), SYSDATE)) END AS EXTRACTION_DATE

FROM DUAL

), BANK_ACCOUNTS AS (

SELECT PPR.PAYROLL_RELATIONSHIP_ID,
PSM.NAME,
ACD.BANK_ID,
ACD.BANK_NAME,
ACD.BANK_NUMBER,
ACD.BANK_CODE,

ACD.BRANCH_ID,
ACD.BRANCH_NUMBER,
ACD.BANK_BRANCH_NAME,

ACD.BANK_ACCOUNT_NUM,
ACD.CHECK_DIGITS,
PPR.PERSON_ID,
PSM.LAST_UPDATE_DATE

FROM PAY_BANK_ACCOUNTS ACD

	-- Param used as Context do Effective Dates --
	INNER JOIN ASSIGN_PARAM ASP
		ON (1 = 1)

	LEFT JOIN PAY_PERSON_PAY_METHODS_F PSM
		ON (PSM.BANK_ACCOUNT_ID = ACD.BANK_ACCOUNT_ID
		AND ASP.EXTRACTION_DATE BETWEEN PSM.EFFECTIVE_START_DATE AND PSM.EFFECTIVE_END_DATE)

	LEFT JOIN PAY_PAY_RELATIONSHIPS_DN PPR
		ON (PPR.PAYROLL_RELATIONSHIP_ID = PSM.PAYROLL_RELATIONSHIP_ID
		AND ASP.EXTRACTION_DATE BETWEEN PPR.START_DATE AND PPR.END_DATE)
	
WHERE 1 = 1

), MANAGER_LOV AS (

SELECT DISTINCT POSM.POSITION_ID,
POSM.POSITION_CODE,
SPA.MANAGER_ASSIGNMENT_ID,
SPA.ASSIGNMENT_ID,
SPA.LAST_UPDATE_DATE

FROM PER_ASSIGNMENT_SUPERVISORS_F SPA

	-- Param used as Context do Effective Dates --
	INNER JOIN ASSIGN_PARAM ASP
		ON (1 = 1)

	INNER JOIN PER_ALL_ASSIGNMENTS_M ASGM
		ON (ASGM.ASSIGNMENT_ID = SPA.MANAGER_ASSIGNMENT_ID
		AND ASGM.ASSIGNMENT_TYPE = 'E'
		--AND ASGM.ASSIGNMENT_STATUS_TYPE = 'ACTIVE'
		AND ASGM.EFFECTIVE_LATEST_CHANGE = 'Y'
		AND TO_CHAR(ASGM.EFFECTIVE_END_DATE, 'YYYY-MM-DD') = '4712-12-31')
	
	INNER JOIN HR_ALL_POSITIONS_F_VL POSM
		ON (POSM.POSITION_ID = ASGM.POSITION_ID
		AND ASP.EXTRACTION_DATE BETWEEN POSM.EFFECTIVE_START_DATE AND POSM.EFFECTIVE_END_DATE)
	
WHERE 1 = 1
AND ASP.EXTRACTION_DATE BETWEEN SPA.EFFECTIVE_START_DATE AND SPA.EFFECTIVE_END_DATE

) /*, ABS_TYPES_ID_LOV AS (

SELECT TPY.ABSENCE_TYPE_ID 

FROM ANC_ABSENCE_TYPES_F TPY
	
	-- Param used as Context do Effective Dates --
	INNER JOIN ASSIGN_PARAM ASP
		ON (1 = 1)

WHERE ASP.EXTRACTION_DATE BETWEEN TPY.EFFECTIVE_START_DATE AND TPY.EFFECTIVE_END_DATE 
AND TPY.BASE_NAME IN ('AFASTAMENTO INSS - AUXILIO DOENÇA_BR', 'AFASTAMENTO INSS - ACIDENTE DE TRABALHO_BR', 'AFASTAMENTO POR ABORTO_BR', 'LICENÇA MATERNIDADE - 30 DIAS POR ADOÇÃO_BR')

)
*/
SELECT * 

FROM (
	SELECT DISTINCT '' AS RH01_ID,
	PEO.PERSON_NUMBER AS RH01_PERSON_NUMBER,
	NAM.FULL_NAME AS RH01_DESC,
	CASE WHEN ASG.ASSIGNMENT_TYPE = 'E' THEN SUBSTR(ASG.ASSIGNMENT_NUMBER, 4, 50)
	ELSE NULL END AS RH01_MATRICULA,
	ASG.ASSIGNMENT_NUMBER AS RH01_MATRICULA_COMPLETA,
	CPF.NATIONAL_IDENTIFIER_NUMBER AS RH01_CPF,
	--REGEXP_REPLACE(CPF.NATIONAL_IDENTIFIER_NUMBER, '[^[:digit:]]') AS CPF_REPL,
	
	PIS.NATIONAL_IDENTIFIER_NUMBER AS RH01_NIS,
	
	-- Review This. We dont have solid Functional Concept about this field
	--'' AS RH01_SITUACAO,
	CASE WHEN ENT.START_DATE IS NOT NULL THEN ENT.ABSENCE_TYPE_ID -- Id Ausencia - Tirei o primeiro CASE 05/08/2024
		WHEN SEV.ACTUAL_TERMINATION_DATE IS NOT NULL THEN 7 -- Desligado
		ELSE 1 -- Normal
		END AS RH01_SITUACAO,
	--
	
	LEP.ORGANIZATION_ID AS RH01_ID_EMPRESA,
	ETP.ATTRIBUTE1 AS RH01_COD_EMPRESA,
	LEP.NAME AS RH01_EMPRESA,
	RA.REGISTRATION_NUMBER AS RH01_CNPJ_EMPRESA,
	
	EST.ORGANIZATION_ID AS RH01_ID_FILIAL,
	RIF.ORG_INFORMATION1 AS RH01_COD_FILIAL,
	EST.NAME AS RH01_FILIAL,
	RE.REGISTRATION_NUMBER AS RH01_CNPJ_FILIAL,
	
	JOB.JOB_ID AS RH01_ID_CARGO,
	JOB.JOB_CODE AS RH01_CODIGO_CARGO,
	JOT.NAME AS RH01_CARGO,
	
	SEO.ORGANIZATION_ID AS RH01_ID_SETOR,
	SEO.INTERNAL_ADDRESS_LINE AS RH01_CODIGO_SETOR,
	SEO.NAME AS RH01_SETOR,
	
	CASE WHEN ASG.ASSIGNMENT_TYPE = 'P' THEN ASG.PROJECTED_START_DATE
	ELSE SEV.DATE_START END AS RH01_DT_ADMISSAO,
	
	BKA.PAYROLL_RELATIONSHIP_ID AS RH01_ID_RELACIONAMENTO_FOLHA,
	BKA.NAME AS RH01_DESC_MET_PAGAMENTO,
	BKA.BANK_ID AS RH01_ID_BANCO,
	BKA.BANK_NAME AS RH01_NOME_BANCO,
	BKA.BANK_NUMBER AS RH01_NUMERO_BANCO,
	BKA.BANK_CODE AS RH01_COD_BANCO,
	
	BKA.BRANCH_ID AS RH01_ID_AGENCIA,
	BKA.BRANCH_NUMBER AS RH01_NUMERO_AGENCIA,
	BKA.BANK_BRANCH_NAME AS RH01_NOME_AGENCIA,
	NULL AS RH01_DIGITO_AGENCIA, -- Pending, Oracle may not have this information
	
	NULL AS RH01_ID_CONTA, -- Pending, Oracle may not have this information
	BKA.BANK_ACCOUNT_NUM AS RH01_NUMERO_CONTA,
	BKA.CHECK_DIGITS AS RH01_DIGITO_CONTA,
	
	ENT.PER_ABSENCE_ENTRY_ID AS RH01_ID_AFASTAMENTO,
	ENT.ABSENCE_TYPE_ID AS RH01_ID_TIPO_AFASTAMENTO,
	ENT.START_DATE AS RH01_DT_AFASTAMENTO,
	
	'' AS RH01_ID_TURNO_PADRAO, -- Pending, Oracle may not have this information
	'' AS RH01_ID_JORNADA, -- Pending, Oracle may not have this information
	
	PSO.DATE_OF_BIRTH AS RH01_DT_NASCIMENTO,
	CASE WHEN SEV.ACTUAL_TERMINATION_DATE IS NOT NULL THEN '0'
	ELSE '1' END AS RH01_ATIVO,
	SEV.ACTUAL_TERMINATION_DATE AS RH01_DATA_DEMISSAO,
	ASG.TERMINATION_DATE AS RH01_ASG_DATA_DEMISSAO,
	'' AS RH01_CAUSA_DEMISSAO, -- Pending, Oracle may not have this information
	PEL.SEX AS RH01_TIPO_SEXO,
	'' AS RH01_ID_ESTABILIDADE, -- Pending, Oracle may not have this information
	
	-- In Oracle Cloud HCM, it is possible to register multiple disabilities, all of which can be active at the same time.
	-- To try abstract the complexity, the interface will always send the max Effective disability
	CASE WHEN DIS.CATEGORY IS NOT NULL THEN '1' ELSE '0' END AS RH01_DEFICIENTE,
	
	PEL.PER_INFORMATION1 AS RH01_NUMERO_CARTEIRA,
	PEL.PER_INFORMATION2 AS RH01_SERIE_CARTEIRA,
	NULL AS RH01_DIGITO_CARTEIRA, -- Pending, Oracle may not have this information
	PEL.PER_INFORMATION_DATE1 AS RH01_DT_EXPEDICAO_CARTEIRA,
	PEL.ATTRIBUTE_DATE1 AS RH01_DT_VENCIMENTO_CARTEIRA,
	GEO.GEOGRAPHY_NAME AS RH01_UF_CARTEIRA,
	RG.NATIONAL_IDENTIFIER_NUMBER AS RH01_RG,
	RG.PLACE_OF_ISSUE AS RH01_ORGAO_EXPEDIDOR, -- Pending, Oracle may not have this information
	
	RG.ISSUE_DATE AS RH01_DT_EXPEDICAO_RG,
	GEOR.GEOGRAPHY_NAME AS RH01_ESTADO_EXPEDIDOR,
	PEO.CREATION_DATE AS RH01_DT_IMPORTACAO,
	--SEV.PDS_INFORMATION9 AS RH01_COD_CATEGORIA,
	POS.ATTRIBUTE2 AS RH01_COD_CATEGORIA,
	NVL(AEI.AEI_INFORMATION_NUMBER2, ASG.ASSIGNMENT_NUMBER) AS RH01_MATESO,
	NAM.KNOWN_AS AS RH01_NOME_SOCIAL,
	
	-- Nested Query Because Its possible to Create more than 1 contact with contact Type Mother (IN_MR)
	-- IN_MR Is Default Value for Contact Type Mother
	NAM2.FULL_NAME AS RH01_DESC_NOME_MAE,
	--
	
	ASG.LAST_UPDATE_DATE AS RH01_DATA_ALTERACAO_CARGO,
	ASG.LAST_UPDATE_DATE AS RH01_DATA_ALTERACAO_SETOR,
	ASG.LAST_UPDATE_DATE AS RH01_DT_ALTERACAO_FILIAL,
	
	PEO.PERSON_ID AS RH01_ID_PESSOA,
	POS.POSITION_ID AS RH01_ID_POSICAO,
	POS.POSITION_CODE AS RH01_CODIGO_POSICAO,
	POS.NAME AS RH01_NOME_POSICAO,
	
	-- Manager Position
	MLO.POSITION_ID AS RH01_ID_POSICAO_SUPERIOR,
	MLO.POSITION_CODE AS RH01_CODIGO_POSICAO_SUPERIOR,
	
	--'' AS RH01_NOME_POSICAO_SUPERIOR,
	ETT.ATTRIBUTE1 AS RH01_COD_AUSENCIA,
	ENT.ABSENCE_TYPE_ID AS RH01_ID_AUSENCIA,
	ETL.NAME AS RH01_DESC_AUSENCIA,
	
	USF.START_DATE AS RH01_USER_DATA_INICIO,
	USF.USER_GUID AS RH01_USER_GUID,
	USF.END_DATE AS RH01_USER_DATA_FIM,
	USF.ACTIVE_FLAG AS RH01_USER_ATIVO,
	
	-- Control Fields
	ASG.ASSIGNMENT_ID AS ASG_ASSIGNMENT_ID,
	ASG.ACTION_CODE AS ASG_ACTION_CODE,
	ASG.EFFECTIVE_START_DATE AS ASG_EFFECTIVE_START_DATE,
	ASG.EFFECTIVE_END_DATE AS ASG_EFFECTIVE_END_DATE,
	ASG.LAST_UPDATE_DATE AS ASG_LAST_UPDATE_DADE,
	ASG.PERSON_ID AS ASG_PERSON_ID,
	ASG.ASSIGNMENT_NUMBER AS ASG_ASSIGNMENT_NUMBER,
	
	-- Employee Tables Context
	PEO.LAST_UPDATE_DATE AS PEO_LAST_UPDATE_DATE,
	PSO.LAST_UPDATE_DATE AS PSO_LAST_UPDATE_DATE,
	NAM.LAST_UPDATE_DATE AS NAM_LAST_UPDATE_DATE,
	PEL.LAST_UPDATE_DATE AS PEL_LAST_UPDATE_DATE,
	CPF.LAST_UPDATE_DATE AS CPF_LAST_UPDATE_DATE,
	RG.LAST_UPDATE_DATE AS RG_LAST_UPDATE_DATE,
	POS.LAST_UPDATE_DATE AS POS_LAST_UPDATE_DATE,
	SEV.LAST_UPDATE_DATE AS SEV_LAST_UPDATE_DATE,
	DIS.LAST_UPDATE_DATE AS DIS_LAST_UPDATE_DATE,
	--PPR.LAST_UPDATE_DATE AS PPR_LAST_UPDATE_DATE,
	--PSM.LAST_UPDATE_DATE AS PSM_LAST_UPDATE_DATE,
	PIS.LAST_UPDATE_DATE AS PIS_LAST_UPDATE_DATE,
	AEI.LAST_UPDATE_DATE AS AEI_LAST_UPDATE_DATE,
	ENT.LAST_UPDATE_DATE AS ENT_LAST_UPDATE_DATE,
	
	
	-- Master Data Used in Employee Context
	LEP.LAST_UPDATE_DATE AS LEP_LAST_UPDATE_DATE,
	EST.LAST_UPDATE_DATE AS EST_LAST_UPDATE_DATE,
	SEO.LAST_UPDATE_DATE AS SEO_LAST_UPDATE_DATE,
	JOB.LAST_UPDATE_DATE AS JOB_LAST_UPDATE_DATE,
	JOT.LAST_UPDATE_DATE AS JOT_LAST_UPDATE_DATE,
	
	-- Max Update Date for Employee and Employment Information
	GREATEST(ASG.LAST_UPDATE_DATE, PEO.LAST_UPDATE_DATE, PSO.LAST_UPDATE_DATE, NVL(NAM.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(PEL.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(CPF.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(RG.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(SEV.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(DIS.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(PIS.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(AEI.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(ENT.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(BKA.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(MLO.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE)) AS RH01_DT_ALTERACAO -- Pending
	
	FROM PER_ALL_ASSIGNMENTS_M ASG
	
		-- Param used as Context do Effective Dates --
		INNER JOIN ASSIGN_PARAM ASP
			ON (1 = 1)
	
		-- Person Informations --
		INNER JOIN PER_ALL_PEOPLE_F PEO
			ON (PEO.PERSON_ID = ASG.PERSON_ID
			AND ASG.EFFECTIVE_END_DATE BETWEEN PEO.EFFECTIVE_START_DATE AND PEO.EFFECTIVE_END_DATE)
	
		INNER JOIN PER_PERSONS PSO
			ON (PSO.PERSON_ID = ASG.PERSON_ID)
		
		INNER JOIN PER_PERSON_NAMES_F NAM
			ON (NAM.PERSON_ID = ASG.PERSON_ID
			AND NAM.NAME_TYPE = 'BR'
			AND ASG.EFFECTIVE_END_DATE BETWEEN NAM.EFFECTIVE_START_DATE AND NAM.EFFECTIVE_END_DATE)
	
		-- If someone has More than 1 Mother this can duplicate the Record
		LEFT JOIN PER_CONTACT_RELSHIPS_F REL
			ON (REL.PERSON_ID = ASG.PERSON_ID
			AND REL.CONTACT_TYPE IN ('1', 'IN_MR')
			AND ASG.EFFECTIVE_END_DATE BETWEEN REL.EFFECTIVE_START_DATE AND REL.EFFECTIVE_END_DATE)
	
		LEFT JOIN PER_PERSON_NAMES_F NAM2
			ON (NAM2.PERSON_ID = REL.CONTACT_PERSON_ID
			AND NAM2.NAME_TYPE = 'BR'
			AND ASG.EFFECTIVE_END_DATE BETWEEN NAM2.EFFECTIVE_START_DATE AND NAM2.EFFECTIVE_END_DATE)
		--
		
		INNER JOIN PER_PEOPLE_LEGISLATIVE_F PEL
			ON (PEL.PERSON_ID = ASG.PERSON_ID
			AND ASG.EFFECTIVE_END_DATE BETWEEN PEL.EFFECTIVE_START_DATE AND PEL.EFFECTIVE_END_DATE)
		
		LEFT JOIN HZ_GEOGRAPHIES GEO
			ON (GEO.GEOGRAPHY_ID = PEL.PER_INFORMATION_NUMBER1
			AND GEO.GEOGRAPHY_ELEMENT1 = 'Brazil'
			AND ASG.EFFECTIVE_END_DATE BETWEEN GEO.START_DATE AND GEO.END_DATE)
	
	
		-- Person Documents --
		INNER JOIN PER_NATIONAL_IDENTIFIERS CPF
			ON (CPF.PERSON_ID = ASG.PERSON_ID
			AND CPF.NATIONAL_IDENTIFIER_TYPE = 'CPF')
			
		LEFT JOIN PER_NATIONAL_IDENTIFIERS RG
			ON (RG.PERSON_ID = ASG.PERSON_ID
			AND RG.NATIONAL_IDENTIFIER_TYPE = 'RG')
			
		LEFT JOIN HZ_GEOGRAPHIES GEOR
			ON (GEOR.GEOGRAPHY_CODE = RG.ATTRIBUTE1
			AND GEOR.GEOGRAPHY_ELEMENT1 = 'Brazil'
			AND ASG.EFFECTIVE_END_DATE BETWEEN GEOR.START_DATE AND GEOR.END_DATE)
			
		LEFT JOIN PER_NATIONAL_IDENTIFIERS PIS
			ON (PIS.PERSON_ID = ASG.PERSON_ID
			AND PIS.NATIONAL_IDENTIFIER_TYPE = 'PIS')
	
		-- Organization Information
		
		-- Legal Entity
		INNER JOIN HR_ORGANIZATION_V LEP
			ON (LEP.ORGANIZATION_ID = ASG.LEGAL_ENTITY_ID
			AND LEP.STATUS = 'A'
			AND LEP.CLASSIFICATION_CODE = 'HCM_LEMP'
			AND ASG.EFFECTIVE_END_DATE BETWEEN LEP.EFFECTIVE_START_DATE AND LEP.EFFECTIVE_END_DATE)
		
		INNER JOIN XLE_ENTITY_PROFILES ETP
			ON (ETP.LEGAL_ENTITY_ID = LEP.LEGAL_ENTITY_ID
			AND ASG.EFFECTIVE_END_DATE BETWEEN NVL(ETP.EFFECTIVE_FROM, TO_DATE('1951-01-01','YYYY-MM-DD')) AND NVL(ETP.EFFECTIVE_TO, TO_DATE('4712-12-31','YYYY-MM-DD')))
	
		INNER JOIN XLE_REGISTRATIONS_V RA
			ON (RA.LEGAL_ENTITY_ID = LEP.LEGAL_ENTITY_ID
			AND ASG.EFFECTIVE_END_DATE BETWEEN NVL(RA.EFFECTIVE_FROM, TO_DATE('1951-01-01','YYYY-MM-DD')) AND NVL(RA.EFFECTIVE_TO, TO_DATE('4712-12-31','YYYY-MM-DD')))
		
		
		-- Reporting Estabilishment
		LEFT JOIN XLE_REGISTRATIONS_V RE
			ON (RE.REGISTRATION_NUMBER = ASG.ASS_ATTRIBUTE19
			AND RE.LEGAL_ENTITY_ID IS NULL
			AND ASG.EFFECTIVE_END_DATE BETWEEN NVL(RE.EFFECTIVE_FROM, TO_DATE('1951-01-01','YYYY-MM-DD')) AND NVL(RE.EFFECTIVE_TO, TO_DATE('4712-12-31','YYYY-MM-DD')))
		
		LEFT JOIN HR_ORGANIZATION_V EST
			ON (EST.ESTABLISHMENT_ID = RE.ESTABLISHMENT_ID
			AND EST.STATUS = 'A'
			AND EST.CLASSIFICATION_CODE = 'HCM_REPORTING_ESTABLISHMENT'
			AND ASG.EFFECTIVE_END_DATE BETWEEN EST.EFFECTIVE_START_DATE AND EST.EFFECTIVE_END_DATE)
		
		LEFT JOIN HR_ORGANIZATION_INFORMATION_F RIF
			ON (RIF.ORG_INFORMATION_CONTEXT = 'LACLS_BR_HCM_LRU_CODE'
			AND RIF.ORGANIZATION_ID = EST.ORGANIZATION_ID
			AND ASG.EFFECTIVE_END_DATE BETWEEN RIF.EFFECTIVE_START_DATE AND RIF.EFFECTIVE_END_DATE)	
		
		-- Department
		LEFT JOIN HR_ORGANIZATION_V SEO
			ON (SEO.ORGANIZATION_ID = ASG.ORGANIZATION_ID
			AND SEO.STATUS = 'A'
			AND SEO.CLASSIFICATION_CODE = 'DEPARTMENT'
			AND ASG.EFFECTIVE_END_DATE BETWEEN SEO.EFFECTIVE_START_DATE AND SEO.EFFECTIVE_END_DATE)
	
	
		-- Assginment Extra Info
		LEFT JOIN PER_JOBS_F JOB
			ON (JOB.JOB_ID = ASG.JOB_ID
			AND ASG.EFFECTIVE_END_DATE BETWEEN JOB.EFFECTIVE_START_DATE AND JOB.EFFECTIVE_END_DATE)
			
		LEFT JOIN PER_JOBS_F_TL JOT
			ON (JOT.JOB_ID = ASG.JOB_ID
			AND JOT.LANGUAGE = 'PTB'
			AND ASG.EFFECTIVE_END_DATE BETWEEN JOT.EFFECTIVE_START_DATE AND JOT.EFFECTIVE_END_DATE)
	
		LEFT JOIN HR_ALL_POSITIONS_F_VL POS
			ON (POS.POSITION_ID = ASG.POSITION_ID
			AND ASG.EFFECTIVE_END_DATE BETWEEN POS.EFFECTIVE_START_DATE AND POS.EFFECTIVE_END_DATE)
	
		LEFT JOIN PER_ASSIGNMENT_EXTRA_INFO_M AEI
			ON (AEI.ASSIGNMENT_ID = ASG.ASSIGNMENT_ID
			AND AEI.INFORMATION_TYPE = 'LACLS_BR_HCM_ADD_PERSONS'
			AND ASG.EFFECTIVE_END_DATE BETWEEN AEI.EFFECTIVE_START_DATE AND AEI.EFFECTIVE_END_DATE)
			
		LEFT JOIN MANAGER_LOV MLO
			ON (MLO.ASSIGNMENT_ID = ASG.ASSIGNMENT_ID)
	
		-- Person Work Relationship Informations
		INNER JOIN PER_PERIODS_OF_SERVICE SEV
			ON (SEV.PERIOD_OF_SERVICE_ID = ASG.PERIOD_OF_SERVICE_ID)
	
	
		-- Disabilities Information --
		-- In Oracle Cloud HCM, it is possible to register multiple disabilities, all of which can be active at the same time.
		-- To try abstract the complexity, the interface will always send the max Effective disability
		LEFT JOIN PER_DISABILITIES_F DIS
			ON (DIS.PERSON_ID = ASG.PERSON_ID
			AND ASG.EFFECTIVE_END_DATE BETWEEN DIS.EFFECTIVE_START_DATE AND DIS.EFFECTIVE_END_DATE
			AND DIS.EFFECTIVE_START_DATE = (SELECT MAX(DIS2.EFFECTIVE_START_DATE) FROM PER_DISABILITIES_F DIS2 WHERE DIS.PERSON_ID = DIS2.PERSON_ID AND DIS2.EFFECTIVE_START_DATE <= ASG.EFFECTIVE_END_DATE))
			--AND DIS.LAST_UPDATE_DATE = (SELECT MAX(DIS3.LAST_UPDATE_DATE) FROM PER_DISABILITIES_F DIS3 WHERE DIS.PERSON_ID = DIS3.PERSON_ID AND DIS.EFFECTIVE_START_DATE = DIS3.EFFECTIVE_START_DATE AND DIS3.EFFECTIVE_START_DATE <= ASG.EFFECTIVE_END_DATE))
		
		
		-- Bank Account Information
		-- Top of Code
		LEFT JOIN BANK_ACCOUNTS BKA
			ON (BKA.PERSON_ID = ASG.PERSON_ID)
		
		-- Absence Information
		LEFT JOIN ANC_PER_ABS_ENTRIES ENT
			ON (ENT.PERSON_ID = ASG.PERSON_ID
			AND ENT.APPROVAL_STATUS_CD = 'APPROVED'
			AND (
					(TRUNC(:P_UpdateDate) BETWEEN TRUNC(ENT.START_DATE) AND TRUNC(NVL(ENT.END_DATE, TO_DATE('4712-12-31', 'YYYY-MM-DD'))))
					OR
					((TRUNC(:P_UpdateDate) BETWEEN TRUNC(ENT.START_DATE) AND TRUNC(NVL(ENT.END_DATE, TO_DATE('4712-12-31', 'YYYY-MM-DD')))) AND (ENT.LAST_UPDATE_DATE > :P_UpdateDate))
				)
			
			-- Used For Extract just Mapped Absences
			--AND ENT.ABSENCE_TYPE_ID IN (SELECT ATL.ABSENCE_TYPE_ID FROM ABS_TYPES_ID_LOV ATL)
			)
			
		LEFT JOIN ANC_ABSENCE_TYPES_F ETT
			ON (ETT.ABSENCE_TYPE_ID = ENT.ABSENCE_TYPE_ID
			AND ETT.LEGISLATION_CODE = 'BR'
			AND ASG.EFFECTIVE_END_DATE BETWEEN ETT.EFFECTIVE_START_DATE AND ETT.EFFECTIVE_END_DATE)
		
		LEFT JOIN ANC_ABSENCE_TYPES_F_TL ETL
			ON (ETL.ABSENCE_TYPE_ID = ENT.ABSENCE_TYPE_ID
			AND ETL.LANGUAGE = 'PTB'
			AND ASG.EFFECTIVE_END_DATE BETWEEN ETL.EFFECTIVE_START_DATE AND ETL.EFFECTIVE_END_DATE)
		
		-- User information
		LEFT JOIN PER_USERS USF
			ON (USF.PERSON_ID = ASG.PERSON_ID)
	
	
	WHERE 1 = 1
	--ASG.ACTION_CODE NOT IN ('GLB_TRANSFER', 'TRANSFER')
	--ASG.ASSIGNMENT_STATUS_TYPE = 'ACTIVE'
	AND (
		-- Polling
		(:P_AsgNumber IS NULL
		AND (
				(TO_CHAR(ASG.EFFECTIVE_END_DATE, 'YYYY-MM-DD') = '4712-12-31') 
				--OR (TO_CHAR(ASG.EFFECTIVE_END_DATE, 'YYYY-MM-DD') != '4712-12-31' AND ASG.ASSIGNMENT_STATUS_TYPE = 'INACTIVE')
			)
		AND GREATEST(ASG.LAST_UPDATE_DATE, PEO.LAST_UPDATE_DATE, PSO.LAST_UPDATE_DATE, NVL(NAM.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(PEL.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(CPF.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(RG.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(SEV.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(DIS.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(PIS.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(AEI.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(ENT.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(BKA.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE), NVL(MLO.LAST_UPDATE_DATE, ASG.LAST_UPDATE_DATE)) > :P_UpdateDate
		) -- Polling Date To Query Just Last Updated Records
	
		-- Reprocess
		OR
		(
			((ASG.ASSIGNMENT_NUMBER = :P_AsgNumber) OR (SUBSTR(ASG.ASSIGNMENT_NUMBER, 3, 50) = :P_AsgNumber))
			AND NVL(:P_UpdateDate, SYSDATE) BETWEEN ASG.EFFECTIVE_START_DATE AND ASG.EFFECTIVE_END_DATE
		)
	
	)
	-- Check if LG Already Update Assignment Number
	AND REGEXP_LIKE(ASG.ASSIGNMENT_NUMBER, '^[0-9]+$')
	AND ASG.EFFECTIVE_LATEST_CHANGE = 'Y'
	AND ASG.ASSIGNMENT_TYPE = 'E'

)

ORDER BY RH01_DT_ALTERACAO ASC
-- Paging
OFFSET NVL(:P_Page * 1000, 0) ROWS FETCH NEXT 1000 ROWS ONLY